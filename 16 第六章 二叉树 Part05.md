# Day 21 第六章 二叉树 Part05

## 今日内容：

● [513.找树左下角的值](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html)
● [112.路径总和](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)
● [113.路径总和ii](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)
● [106.从中序与后序遍历序列构造二叉树](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)
● [105.从前序与中序遍历序列构造二叉树](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)


## 513.找树左下角的值
### 递归
- 如果使用递归法，如何判断是最后一行呢，其实就是**深度最大的叶子节点一定是最后一行** - 找深度最大的叶子节点。
- 1 确定递归函数的参数和返回值: 参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。
- 2 确定终止条件: 当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。
- 3 确定单层递归的逻辑: 在找最大深度的时候，递归的过程中依然要使用回溯
- 本题还需要类里的两个全局变量，maxLen用来记录最大深度，result记录最大深度最左节点的数值。
```cpp
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            depth++;
            traversal(root->left, depth);
            depth--; // 回溯
        }
        if (root->right) {
            depth++;
            traversal(root->right, depth);
            depth--; // 回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```

### 迭代
- 思路简单， 层序遍历即可
```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

## 112.路径总和
### 递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：
- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

### 递归
- 确定递归函数的参数和返回类型: 遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。
- 确定终止条件: 可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。
- 确定单层递归的逻辑: 因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。
```cpp
class Solution {
public:
    bool traversal(TreeNode* node, int counter)
    {
            if (node->left == nullptr && node->right == nullptr && counter == 0) return true;
            if (node->left == nullptr && node->right == nullptr && counter != 0) return false;

            if (node->left)
            {
              if( traversal(node->left, counter -  node->left->val)) return true;
            }

            if (node->right)
            {
              if ( traversal(node->right, counter - node->right->val)) return true; 
            }
            return false;
    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return false;
        return traversal(root, targetSum - root->val);
    }
};
```

## 113.路径总和ii
- 要遍历整个树，找到所有路径，**所以递归函数不要返回值**！
```cpp
class Solution {
public:
    void traversal(TreeNode* curNode, int counter, vector<int> path, vector<vector<int>>& result)
    {
        if (curNode->left) 
        {   
            path.push_back(curNode->left->val);
            counter -= curNode->left->val;
            traversal(curNode->left, counter, path, result );
            path.pop_back();
            counter += curNode->left->val;
        }
        
       if (curNode->right)
       {
            path.push_back(curNode->right->val);
            counter -= curNode->right->val;
            traversal(curNode->right, counter, path, result);
            path.pop_back();
            counter += curNode->right->val;
       }

        if (!curNode->left && !curNode->right)
        {
           if (counter == 0) result.push_back(path);
           return;
        }

        return;
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        
        vector<vector<int>> result;
        if (!root) return result;
        vector<int> path;
        path.push_back(root->val);
        traversal(root, targetSum - root->val, path, result);
        return result;
    }
};
```

## 106.从中序与后序遍历序列构造二叉树


## 105.从前序与中序遍历序列构造二叉树

