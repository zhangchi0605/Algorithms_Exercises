# Day 22 第六章 二叉树 Part06

## 今日内容：

● [654.最大二叉树](https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
● [617.合并二叉树](https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
● [700.二叉搜索树中的搜索](https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html)
● [98.验证二叉搜索树](https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)

## 654.最大二叉树
- 思路： 可以使用 [106.从中序与后序遍历序列构造二叉树](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html) 相同的思路构建二叉树。
```cpp
class Solution {
public:
    TreeNode* traversal(vector<int>& nums, int beginIndex, int endIndex)
    {
        if (endIndex - beginIndex == 0) return nullptr;

        int max = INT32_MIN;
        int maxIndex;
        for (int i = beginIndex; i < endIndex; i++)
        {
            if (max < nums[i])
            {
                max = nums[i];
                maxIndex = i;
            }
        }

        TreeNode* root = new TreeNode(max);
        if (endIndex - beginIndex == 1) return root;

        int leftBeginIndex = beginIndex;
        int leftEndIndex = maxIndex;

        int rightBeginIndex = maxIndex + 1;
        int rightEndIndex = endIndex;
        
        root->left = traversal(nums, leftBeginIndex, leftEndIndex);
        root->right = traversal(nums, rightBeginIndex, rightEndIndex);

        return root;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }   
};
```

## 617.合并二叉树

## 700.二叉搜索树中的搜索

## 98.验证二叉搜索树

